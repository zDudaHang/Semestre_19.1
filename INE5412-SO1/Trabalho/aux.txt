//------------------------------------------------------------------------------ ALTERACAO
PUBLIC int nice_to_weight(int nice) {
	weight = 32768/(1.25)**(nice);
	return weight;
}

PUBLIC int sum_weights(void) {
	int sum = 0;
	for (p = FIRST_PROC; p <= LAST_PROC; p++) {
		sum += nice_to_weight(p->nice);
	}
	return sum;
}

PUBLIC int count_ready_tasks(void) {
	int sum = 0;
	for (p = FIRST_PROC; p <= LAST_PROC; p++) {
		if(p->state == PROC_READY) {
			sum++;
		}
	}
	return sum;
}

PUBLIC int define_period(void) {
	int period = SCHED_LATENCY;
	int canServe = SCHED_LATENCY/SCHED_MIN_GRANULARITY; // Representa quantas threads consegue atender com o SCHED_LATENCY
	int num_ready_tasks = count_ready_tasks();
	if (num_ready_tasks > canServe) { // NÃ£o consegue atender todas
		period = SCHED_MIN_GRANULARITY * num_ready_tasks; // Arruma o periodo para atender todas minimamente
	}
	return period;
}

PUBLIC int define_time_slice(process* curr) {
	int period = define_period();
	slice = period * (nice_to_weight(curr->nice)/sum_weights);
	return slice;
}

PUBLIC process get_process_with_min_vruntime(void) {
	int min_vruntime = 0;
	process * min_p;
	for (p = FIRST_PROC; p <= LAST_PROC; p++) {
		if (p->vruntime < min_vruntime) {
			min_p = p;
			min_vruntime = p->vruntime;
	}
	return min_p;
}
//------------------------------------------------------------------------------ ALTERACAO

/* Choose a process to run next. */
	next = IDLE;
	process *min_p = get_process_with_min_vruntime();

	if (curr_proc->vruntime > min_p->vruntime) {
		next = min_p;
	}
	
